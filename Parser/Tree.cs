//
//  This is the helper file for the RealTree example
//  program.  It is an example program for use of the
//  GPPG parser generator.  Copyright (c) K John Gough 2012
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq.Expressions;
using System.Runtime.InteropServices.JavaScript;
using System.Text;
using QUT.Gppg;

namespace NCCompiler_CompilersCourse.Parser {
    //
    // There are several classes defined here.
    //
    // The parser class is named Parser (the gppg default),
    // and contains a handwritten scanner with class name
    // RealTree.Parser.Lexer.
    //
    // The Parser class is partial, so that most of the 
    // handwritten code may be placed in this file in a
    // second part of the class definition.
    //
    // This file also contains the class hierarchy for the
    // semantic action class RealTree.Node
    //
    // The token enumeration RealTree.Parser.Tokens (also
    // the gppg default) is generated by gppg.
    //
    internal partial class Parser {

        // 
        // GPPG does not create a default parser constructor
        // Most applications will have a parser type with other
        // fields such as error handlers etc.  Here is a minimal
        // version that just adds the default scanner object.
        // 

        Parser( Lexer s ) : base( s ) { }

        internal Dictionary<string, Node> regs = new Dictionary<string, Node>();

        // ==================================================================================

        static void Main(string[] args) {
            System.IO.TextReader reader;
            if (args.Length > 0)
                reader = new System.IO.StreamReader( args[0] );
            else
                reader = System.Console.In;

            Parser parser = new Parser( new Lexer( reader ) );
            Console.WriteLine( "RealCalc expression evaluator, type ^C to exit, help for help" );
            parser.Parse();
        }

        // ==================================================================================
        //  Version for real arithmetic.  YYSTYPE is RealTree.Node
        //  This version uses an embedded scanner rather than a gplex-generated one.
        //
        class Lexer : QUT.Gppg.AbstractScanner<RealTree.Node, LexLocation> {
            private System.IO.TextReader reader;
            private StringBuilder text = new StringBuilder();

            public Lexer( System.IO.TextReader reader ) {
                this.reader = reader;
            }

            private LexLocation singleton = new LexLocation();
            public override LexLocation yylloc {
                get { return singleton; }
            }

            public override int yylex() {
                char ch;
                char peek;
                int ord = reader.Read();
                //this.text.Clear();
                this.text.Length = 0;
                //
                // Must check for EOF
                //
                if (ord == -1)
                    return (int)Tokens.EOF;
                else
                    ch = (char)ord;

                if (ch == '\n')
                    return (int)Tokens.EOL;
                else if (char.IsWhiteSpace( ch )) { // Skip white space
                    while (char.IsWhiteSpace( peek = (char)reader.Peek() )) {
                        ord = reader.Read();
                        if (ord == (int)'\n')
                            return (int)Tokens.EOL; ;
                    }
                    return yylex();
                }
                else if (char.IsDigit( ch )) {
                    text.Append( ch );
                    while (char.IsDigit( peek = (char)reader.Peek() ))
                        text.Append( (char)reader.Read() );
                    if ((peek = (char)reader.Peek()) == '.')
                        text.Append( (char)reader.Read() );
                    while (char.IsDigit( peek = (char)reader.Peek() ))
                        text.Append( (char)reader.Read() );
                    try {
                        yylval = Parser.MakeConstLeaf( double.Parse( text.ToString() ) );
                        return (int)Tokens.LITERAL;
                    }
                    catch (FormatException) {
                        this.yyerror( "Illegal number \"{0}\"", text );
                        return (int)Tokens.error;
                    }
                }
                else if (char.IsLetter( ch )) {
                    text.Append( char.ToLower( ch ) );
                    while (char.IsLetter( peek = (char)reader.Peek() ))
                        text.Append( char.ToLower( (char)reader.Read() ) );
                    switch (text.ToString()) {
                        case "eval":
                            return (int)Tokens.EVAL;
                        case "exit":
                            return (int)Tokens.EXIT;
                        case "help":
                            return (int)Tokens.HELP;
                        case "reset":
                            return (int)Tokens.RESET;
                        case "print":
                            return (int)Tokens.PRINT;
                        default:
                            if (text.Length == 1) {
                                yylval = Parser.MakeIdLeaf( text[0] );
                                return (int)Tokens.LETTER;
                            }
                            else {
                                this.yyerror( "Illegal name \"{0}\"", text );
                                return (int)Tokens.error;
                            }
                    }
                }
                else
                    switch (ch) {
                        case '.': case '+': case '-': case '*':
                        case '/': case '(': case ')': case '%': case '=':
                            return ch;
                        case ';':
                            return (int)Tokens.EOL; ; // semicolon treated as command separator.
                        default:
                            yyerror( "Illegal character '{0}'", ch );
                            return yylex();
                    }
            }

            public override void yyerror( string format, params object[] args ) {
                Console.Error.WriteLine( format, args );
            }
        }
        // ==================================================================================
        //  End of Lexer class definition.
        // ==================================================================================

        //
        // Now the node factory methods
        //
        public static Node MakeBinary( NodeTag tag, Node lhs, Node rhs ) {
            return new Binary( tag, lhs, rhs );
        }
        
        public static Node MakeComparison( NodeTag tag, Node lhs, Node rhs ) {
            return new Comparison( tag, lhs, rhs );
        }
        
        public static Node MakeBoolean( NodeTag tag, Node lhs, Node rhs ) {
            return new Boolean( tag, lhs, rhs );
        }

        public static Node MakeUnary(NodeTag tag, Node child) {
            return new Unary( tag, child );
        }

        public static Node MakeIdLeaf(string name) {
            return new Leaf( name );
        }

        public static Node MakeIntLeaf(double value) {
            return new Leaf( value );
        }
        
        public static Node MakeBoolLeaf(double value) {
            return new Leaf( value );
        }
        
        public static Node MakeDoubleLeaf(double value) {
            return new Leaf( value );
        }

        // ==================================================================================
        // And the semantic helpers
        // ==================================================================================
        private void PrintHelp() {
            Console.WriteLine(
@"RealTree: there are 26 variables named 'a' .. 'z'. Names are case insensitive,
and expressions may reference literals or variables. Variables are either empty
or contain expression trees. Literals are a trivial case of a valid tree.
Commands are separated by newlines, or by semicolons ';'.  Valid commands are --
    > help              // print this notice.
    > exit              // exit the program. ^C works as well.
    > print             // prints the value of each valid variable.
    > reset             // clears all variables
    > eval expression   // evaluate the expression
    > eval x            // x is a variable containing an expression tree
    > x = expression    // store the expression tree in variable x.");
        }

        private void ClearRegisters() {
            for (int i = 0; i < regs.Length; i++)
                regs[i] = null;
        }

        private void PrintRegisters() {
            for (int i = 0; i < regs.Length; i++)
                if (regs[i] != null)
                    Console.WriteLine( "regs[{0}] = '{1}' = {2}", i, (char)(i + (int)'a'), regs[i].Unparse());
        }

        private void AssignExpression( Leaf dst, Node expr ) {
            Leaf destination = dst as Leaf;
            regs[destination.Index] = expr;
        }

        private void CallExit() {
            Console.Error.WriteLine( "RealTree will exit" );
            System.Environment.Exit( 1 );
        }

        private double Eval( Node node ) {
            try {
                return node.Eval( this );
            }
            catch (CircularEvalException) {
                Scanner.yyerror( "Eval has circular dependencies" );
            }
            catch {
                Scanner.yyerror( "Invalid expression evaluation" );
            }
            return 0.0;
        }

        private void Display( Node node ) {
            try {
                double result = node.Eval( this );
                Console.WriteLine( "result: " + result.ToString() );
            }
            catch (CircularEvalException) {
                Scanner.yyerror( "Eval has circular dependencies" );
            }
            catch {
                Scanner.yyerror( "Invalid expression evaluation" );
            }
        }

        public class CircularEvalException : Exception {
            internal CircularEvalException() { }
        }
    }

    // ==================================================================================
    //  Start of Node Definitions
    // ==================================================================================

    internal enum NodeTag { error, name, bool_literal, int_literal, double_literal, plus, minus, mul, div, rem, and, or, xor, not, negation, ge, gt, le, lt, eq, ne, _if }

    internal abstract class Node {
        readonly NodeTag tag;
        protected bool active = false;
        public NodeTag Tag => tag;

        protected Node(NodeTag tag ) { this.tag = tag; }
        public abstract Object Eval( Parser p );
        public abstract string Unparse();

        public void Prolog() {
            if (active)
                throw new Parser.CircularEvalException();
            active = true;
        }

        public void Epilog() { active = false; }
    }

    internal class Leaf : Node {
        private readonly string _name;
        private readonly Object _value;
        internal Leaf( string name ) : base( NodeTag.name ) { _name = name; }
        internal Leaf(Boolean value) : base(NodeTag.bool_literal ) { _value = value; }
        internal Leaf(Int32 value) : base(NodeTag.int_literal ) { _value = value; }
        internal Leaf(Double value) : base(NodeTag.double_literal ) { _value = value; }
        
        public string Index { get { return _name; } }

        public override Object Eval( Parser p ) {
            try {
                Prolog();
                if (Tag == NodeTag.name)
                    return p.regs[_name].Eval(p);
                else
                    return _value;
            }
            finally {
                Epilog();
            }
        }

        public override string Unparse() {
            if (Tag == NodeTag.name)
                return _name;
            else
                return _value.ToString();
        }
    }
    
    internal class ModifiablePrimaryNode : Node
    {
        private readonly Leaf _leaf;
        private readonly SizeNode _size;
        private readonly ModifiablePrimaryNode _modifiablePrimaryNode;
        private readonly ExpressionNode _exprNode;

        public ModifiablePrimaryNode(IdentifierNode identifier) : base(primary_identifier)
        {
            this._identifier = _identifier;
        }
        
        public ModifiablePrimaryNode(ModifiablePrimaryNode identifier, ) : base(primary_identifier)
        {
            this._identifier = _identifier;
        }

        public override object Eval(Parser p)
        {
            throw new NotImplementedException();
        }

        public override string Unparse()
        {
            throw new NotImplementedException();
        }
    }
    
    internal class ArrayNode : Node {
        private readonly string _name;
        private readonly ArrayList _value;
        internal ArrayLeaf( string name ) : base( NodeTag.name ) { _name = name; }
        
        internal ArrayLeaf( ArrayList list) : base(NodeTag.literal ) { _value = list; }
        internal ArrayLeaf( int size) : base(NodeTag.literal ) { _value = new ArrayList(size); }

        public override double Eval( Parser p ) {
            try {
                Prolog();
                if (Tag == NodeTag.name)
                    return p.regs[_name].Eval(p);
                else
                    return _value;
            }
            finally {
                Epilog();
            }
        }

        public override string Unparse() {
            if (Tag == NodeTag.name)
                return _name;
            else
                return _value.ToString();
        }
    }
    
    internal class IfNode : Node {
        private readonly Node _condition;
        private readonly Node _if_body;
        private readonly Node? _else_body;

        internal IfNode(Node condition, Node ifBody) : base(NodeTag._if)
        {
            _condition = condition;
            _if_body = ifBody;
        }
        
        internal IfNode(Node condition, Node ifBody, Node elseBody) : base(NodeTag._if)
        {
            _condition = condition;
            _if_body = ifBody;
            _else_body = elseBody;
        }

        public override double Eval( Parser p ) {
            try {
                Prolog();
                if (Tag == NodeTag._if)
                    return p.regs[_name].Eval(p);
                else
                    return _value;
            }
            finally {
                Epilog();
            }
        }

        public override string Unparse() {
            if (Tag == NodeTag.name)
                return _name;
            else
                return _value.ToString();
        }
    }

    internal class Unary : Node {
        Node _child;
        internal Unary(NodeTag t, Node c )
            : base( t ) { _child = c; }

        public override double Eval( Parser p ) {
            try
            {
                Prolog();
                if (Tag == NodeTag.negation)
                    return -_child.Eval(p);
                else if (Tag == NodeTag.not)
                {
                    double result = _child.Eval(p);
                    if ((int)result == 0)
                        return 1;
                    else if ((int)result == 1)
                        return 0;
                    throw new Exception("invalid boolean operand");
                }
                else
                {
                    throw new Exception("unsupported unary operation");
                }
            }
            finally {
                Epilog();
            }
        }

        public override string Unparse() {
            if (Tag == NodeTag.negation)
                return $"( - {_child.Unparse()})";
            else 
                return $"( not {_child.Unparse()})";
        }
    }

    internal class Binary : Node {
        private readonly Node _lhs;
        private readonly Node _rhs;

        internal Binary(NodeTag t, Node l, Node r ) : base( t ) { 
            _lhs = l; _rhs = r; 
        }

        public override double Eval( Parser p ) {
            try {
                Prolog();
                double lVal = _lhs.Eval( p );
                double rVal = _rhs.Eval( p );
                switch (Tag) {
                    case NodeTag.div: return lVal / rVal;
                    case NodeTag.minus: return lVal - rVal;
                    case NodeTag.plus: return lVal + rVal;
                    case NodeTag.rem: return lVal % rVal;
                    case NodeTag.mul: return lVal * rVal;
                    default: throw new Exception( "bad tag" );
                }
            }
            finally {
                Epilog();
            }
        }
        
        

        public override string Unparse() {
            string op = "";
            switch (Tag) {
                case NodeTag.div:   op = "/"; break;
                case NodeTag.minus: op = "-"; break;
                case NodeTag.plus:  op = "+"; break;
                case NodeTag.rem:   op = "%"; break;
                case NodeTag.mul:   op = "*"; break;
            }
            return $"({_lhs.Unparse()} {op} {_rhs.Unparse()})";
        }
    }
    
    internal class Boolean : Node {
        private readonly Node _lhs;
        private readonly Node _rhs;

        internal Boolean(NodeTag t, Node l, Node r ) : base( t ) { 
            _lhs = l; _rhs = r; 
        }

        public override double Eval( Parser p ) {
            try {
                Prolog();
                double lVal = _lhs.Eval( p );
                double rVal = _rhs.Eval( p );
                if (lVal is not (0 or 1)) throw new Exception("invalid boolean operand");
                if (rVal is not (0 or 1)) throw new Exception("invalid boolean operand");
                bool boolLVal = (int) lVal == 1;
                bool boolRVal = (int) rVal == 1;
                switch (Tag) {
                    case NodeTag.and: return (boolLVal && boolRVal) ? 1 : 0;
                    case NodeTag.or: return (boolLVal || boolRVal) ? 1 : 0;
                    case NodeTag.xor: return (boolLVal ^ boolRVal) ? 1 : 0;
                    default: throw new Exception( "bad tag" );
                }
            }
            finally {
                Epilog();
            }
        }
        
        

        public override string Unparse() {
            string op = "";
            switch (Tag) {
                case NodeTag.and:   op = "and"; break;
                case NodeTag.or: op = "or"; break;
                case NodeTag.xor:  op = "xor"; break;
            }
            return $"({_lhs.Unparse()} {op} {_rhs.Unparse()})";
        }
    }
    
    internal class Comparison : Node {
        private readonly Node _lhs;
        private readonly Node _rhs;

        internal Comparison(NodeTag t, Node l, Node r ) : base( t ) { 
            _lhs = l; _rhs = r; 
        }

        public override double Eval( Parser p ) {
            try {
                Prolog();
                double lVal = _lhs.Eval( p );
                double rVal = _rhs.Eval( p );
                switch (Tag) {
                    case NodeTag.lt: return lVal < rVal ? 1 : 0;
                    case NodeTag.le: return lVal <= rVal ? 1 : 0;
                    case NodeTag.gt: return lVal > rVal ? 1 : 0;
                    case NodeTag.ge: return lVal >= rVal ? 1 : 0;
                    case NodeTag.ne: return Math.Abs(lVal - rVal) > 0.0000001 ? 1 : 0;
                    case NodeTag.eq: return Math.Abs(lVal - rVal) < 0.0000001 ? 1 : 0;
                    default: throw new Exception( "bad tag" );
                }
            }
            finally {
                Epilog();
            }
        }
        
        

        public override string Unparse() {
            string op = "";
            switch (Tag) {
                case NodeTag.lt: op = "<"; break;
                case NodeTag.le: op = "<="; break;
                case NodeTag.gt: op = ">"; break;
                case NodeTag.ge: op = ">="; break;
                case NodeTag.ne: op = "/="; break;
                case NodeTag.eq: op = "="; break;
            }
            return $"({_lhs.Unparse()} {op} {_rhs.Unparse()})";
        }
    }
    // ==================================================================================
}